\documentclass[
  a4paper,
  11pt,
]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[
  %cm,
  headings
]{fullpage}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{satz}{Satz}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{beispiel}{Beispiel}

\usepackage{minted}
\usepackage{listings}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{booktabs}

\usepackage[]{algorithm}
\usepackage[]{algorithmic}
\floatname{algorithm}{Algorithmus}

% Für Zeilenumbrüche ohne Indentations
\setlength{\parindent}{0pt}

% coole Kopf- und Fußzeilen:
\usepackage{fancyhdr}
% Seitenstil ist natürlich fancy:
\pagestyle{fancy}
% alle Felder löschen:
\fancyhf{}

\fancyhead[L]{%
  Seminar: Public-Key-Kryptographie
}
\fancyhead[R]{%
}
%\fancyfoot[L]{}
\fancyfoot[C]{\thepage}

\usepackage{todonotes}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\ggT}{\text{ggT}}

\title{Diskrete Logarithmen}

\subtitle{Seminar: Public-Key-Kryptographie}

\author{%
  Martin Darmüntzel \and Hannes Kleinwort
}

\begin{document}

\maketitle

\section{Mathematische Grundlagen}
\label{sec:mathematische_grundlagen}

\begin{definition}[Prime Restklassengruppe]
  Die \emph{prime Restklassengruppe} ist die multiplikative Gruppe der
  Restklassen bezüglich eines Moduls $p$, die zu $p$ teilerfremd sind. Sie wird
  als $\Z_p^*$ notiert.
\end{definition}

Die Bedingung der Teilerfremdheit der einzelnen Elemente $a \in \Z_p^*$ zum
Modul $p$ drückt sich durch $\ggT(a, p) = 1$ für alle $a \in \Z_p^*$ aus. Durch
diese Bedingung und dem Lemma von Bézout hat jedes Element ein multiplikatives
Inverses in $\Z_p^*$. Falls $p$ eine Primzahl ist, dann besteht $\Z_p^*$ aus
der Menge $\left\{1, \ldots, p-1\right\}$, da alle Zahlen aus dieser Menge
teilerfremd zu $p$ sind. Im Allgemeinen ist die Ordnung von $\Z_p^*$ durch die
Eulersche $\varphi$-Funktion bestimmt:
\begin{align*}
  \left| \Z_p^* \right| = \varphi(p)
\end{align*}
Dies ergibt sich direkt aus der Definition der Eulerschen $\varphi$-Funktion.

\begin{definition}[Erzeuger]
  Wenn es ein Element $a \in \Z_p^*$ gibt, dessen Potenzen $a^n$ für
  $n \in \Z_p^*$ alle Elemente aus $\Z_p^*$ erzeugt, dann nennt man $a$ einen
  Erzeuger. In $\Z_p^*$ heißen die Erzeuger auch \emph{Primitivwurzeln} modulo
  $p$.
\end{definition}

\begin{beispiel}[Erzeuger]\label{bsp:erzeuger}
  Betrachten wir $\Z_{13}^*$. In dieser Gruppe ist $2$ ein Erzeuger, was man
  durch das Ausrechnen der einzelnen Potenzen überprüfen kann:
  \begin{center}
    \begin{tabular}{r*{12}{r}}
      \toprule
      $x$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $10$ & $11$ & $12$\\
      \midrule
      $2^x \Mod{13}$ & $2$ & $4$ & $8$ & $3$ & $6$ & $12$ & $11$ & $9$ & $5$ & $10$ & $7$ & $1$\\
      \bottomrule
    \end{tabular}
  \end{center}
  Das Element $3$ ist hingegen kein Erzeuger:
  \begin{center}
    \begin{tabular}{r*{12}{r}}
      \toprule
      $x$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $10$ & $11$ & $12$\\
      \midrule
      $3^x \Mod{13}$ & $3$ & $9$ & $1$ & $3$ & $9$ & $1$ & $3$ & $9$ & $1$ & $3$ & $9$ & $1$\\
      \bottomrule
    \end{tabular}
  \end{center}
\end{beispiel}
\begin{definition}[Diskrete Exponentiation, diskreter Logarithmus]
  Sei $g$ ein Erzeuger von $\Z_p^*$. Die diskrete Exponentiation zur Basis $g$
  ist eine Abbildung von $\Z_p^* \to \Z_p^*$ und definiert durch:
  \begin{align*}
    \exp_g: \quad \Z_p^* \to \Z_p^*\\
    x \mapsto g^x
  \end{align*}
  Die dazugehörige Umkehrfunktion
  \begin{align*}
    \log_g: \quad \Z_p^* & \to \Z_p^*\\
    x & \mapsto \log_g x
  \end{align*}
  heißt \emph{diskreter Logarithmus} zur Basis $g$.
\end{definition}

\begin{definition}[Diskretes Logarithmusproblem]\label{def:diskretes_logarithmusproblem}
  Sei $p$ eine Primzahl, $g$ ein Erzeuger von $\Z_p^*$ und $y \in \Z_p^*$.

  Finde ein $x$ mit $1 \leq x \leq p-1$, so dass $g^x \equiv y \mod p$ gilt.
\end{definition}

\section{Anwendung: Ver- und Entschlüsselung}
\label{sec:anwendung_ver_und_entschlusselung}

\section{Berechnung von diskreten Logarithmen}
\label{sec:berechnung_von_diskreten_logarithmen}

\subsection{Naive Berechnung}
\label{sub:naive_berechnung}

Die einfachste Möglichkeit für die Berechnung des diskreten Logarithmus ist das
Durchprobieren. Wir erinnern uns an das \todo{verlinken} diskrete
Logarithmusproblem: gegeben sei eine Primzahl $p$, ein
Erzeuger $g$ der Gruppe $\Z_p^*$ und ein Element $y$ aus dieser Gruppe. Wir
suchen den Exponenten $x \in \Z_p^*$ für den gilt:
\begin{align*}
  g^x \equiv y \mod p
\end{align*}
Da $\Z_p^*$ nur endlich viele Element enthält, können wir für jedes $x$
überprüfen, ob es die Kongruenz erfüllt.

\begin{algorithm}
  \caption{naiver Berechnungsalgorithmus}
  \begin{algorithmic}
    \REQUIRE{$p \in \P, \left\langle g \right\rangle \in \Z_p^*, y \in \Z_p^*$}
    \FORALL{$x \in \left\{1, \ldots, p-1\right\}$}
      \IF{$g^x \equiv y \mod p$}
        \RETURN{$x$}
      \ELSE{}
        \STATE{$x \leftarrow x + 1$}
      \ENDIF{}
    \ENDFOR{}
  \end{algorithmic}
\end{algorithm}

\begin{listing}[H]
  \caption{Implementation des naiven Berechnungsalgorithmus’}
  \begin{minted}{python}
    def dlog_naive(root, modulus, value):
        for x in range(1, modulus):
            if pow(root, x, modulus) == value:
                return x
  \end{minted}
\end{listing}

\end{document}
