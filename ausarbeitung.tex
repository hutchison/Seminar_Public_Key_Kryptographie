\documentclass[
  a4paper,
  11pt,
]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[
  %cm,
  headings
]{fullpage}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{satz}{Satz}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{beispiel}{Beispiel}

\usepackage{minted}
\usepackage{listings}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{booktabs}

\usepackage[]{algorithm}
\usepackage[]{algorithmic}
\floatname{algorithm}{Algorithmus}

% Für Zeilenumbrüche ohne Indentations
\setlength{\parindent}{0pt}

% coole Kopf- und Fußzeilen:
\usepackage{fancyhdr}
% Seitenstil ist natürlich fancy:
\pagestyle{fancy}
% alle Felder löschen:
\fancyhf{}

\fancyhead[L]{%
  Seminar: Public-Key-Kryptographie
}
\fancyhead[R]{%
}
%\fancyfoot[L]{}
\fancyfoot[C]{\thepage}

\usepackage{todonotes}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\ggT}{\text{ggT}}
\newcommand{\Mod}[1]{\ \mathrm{mod}\ #1}

\title{Diskrete Logarithmen}

\subtitle{Seminar: Public-Key-Kryptographie}

\author{%
  Martin Darmüntzel \and Hannes Kleinwort
}

\begin{document}

\maketitle

\section{Mathematische Grundlagen}
\label{sec:mathematische_grundlagen}

\begin{definition}[Prime Restklassengruppe]
  Die \emph{prime Restklassengruppe} ist die multiplikative Gruppe der
  Restklassen bezüglich eines Moduls $p$, die zu $p$ teilerfremd sind. Sie wird
  als $\Z_p^*$ notiert.
\end{definition}

Die Bedingung der Teilerfremdheit der einzelnen Elemente $a \in \Z_p^*$ zum
Modul $p$ drückt sich durch $\ggT(a, p) = 1$ für alle $a \in \Z_p^*$ aus. Durch
diese Bedingung und dem Lemma von Bézout hat jedes Element ein multiplikatives
Inverses in $\Z_p^*$. Falls $p$ eine Primzahl ist, dann besteht $\Z_p^*$ aus
der Menge $\left\{1, \ldots, p-1\right\}$, da alle Zahlen aus dieser Menge
teilerfremd zu $p$ sind. Im Allgemeinen ist die Ordnung von $\Z_p^*$ durch die
Eulersche $\varphi$-Funktion bestimmt:
\begin{align*}
  \left| \Z_p^* \right| = \varphi(p)
\end{align*}
Dies ergibt sich direkt aus der Definition der Eulerschen $\varphi$-Funktion.

\begin{definition}[Erzeuger]
  Wenn es ein Element $a \in \Z_p^*$ gibt, dessen Potenzen $a^n$ für
  $n \in \Z_p^*$ alle Elemente aus $\Z_p^*$ erzeugt, dann nennt man $a$ einen
  Erzeuger. In $\Z_p^*$ heißen die Erzeuger auch \emph{Primitivwurzeln} modulo
  $p$.
\end{definition}

\begin{beispiel}[Erzeuger]\label{bsp:erzeuger}
  Betrachten wir $\Z_{13}^*$. In dieser Gruppe ist $2$ ein Erzeuger, was man
  durch das Ausrechnen der einzelnen Potenzen überprüfen kann:
  \begin{center}
    \begin{tabular}{r*{12}{r}}
      \toprule
      $x$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $10$ & $11$ & $12$\\
      \midrule
      $2^x \Mod{13}$ & $2$ & $4$ & $8$ & $3$ & $6$ & $12$ & $11$ & $9$ & $5$ & $10$ & $7$ & $1$\\
      \bottomrule
    \end{tabular}
  \end{center}
  Das Element $3$ ist hingegen kein Erzeuger:
  \begin{center}
    \begin{tabular}{r*{12}{r}}
      \toprule
      $x$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $10$ & $11$ & $12$\\
      \midrule
      $3^x \Mod{13}$ & $3$ & $9$ & $1$ & $3$ & $9$ & $1$ & $3$ & $9$ & $1$ & $3$ & $9$ & $1$\\
      \bottomrule
    \end{tabular}
  \end{center}
\end{beispiel}

Um herauszufinden, ob ein Element $a \in \Z_p^*$ eine Primitivwurzel ist, müsste
man testen, ob die Potenzen $a^x$ mit $x \in \Z_p^*$ wieder alle Elemente von
$\Z_p^*$ ergeben. Dies ist für große Moduli jedoch sehr aufwändig. Wir können
diesen Test abkürzen, indem wir uns folgende Beobachtung aus
Beispiel~\ref{bsp:erzeuger} zunutze machen: nach dem kleinen Satz von Fermat
muss für jedes Element $a$ aus $\Z_p^*$ die Kongruenz
\begin{align*}
  a^{p-1} \equiv 1 \mod p
\end{align*}
gelten. Für das Element $3 \in \Z_{13}^*$ gilt sie jedoch auch für die
Exponenten $3, 6$ und $9$. Wir müssen demnach nur für bestimmte Exponenten $x$
prüfen, ob $a^x \equiv 1 \mod p$ gilt und falls das der Fall ist, kann $a$ keine
Primitivwurzel sein. Welche Exponenten dies sind, zeigt der folgende Satz.

\begin{satz}\label{satz:primitivwurzeltest}
  Sei $p$ eine Primzahl größer als $2$ und
  $p-1 = q_1^{k_1} \cdot \ldots \cdot q_r^{k_r}$ die Primfaktorzerlegung von
  $p-1$. Eine ganze Zahl $a$ mit $p \nmid a$ ist genau dann Primitivwurzel
  modulo $p$, wenn
  \begin{align*}
    a^{(p-1)/q_i} & \not\equiv 1 \mod p \qquad \text{ für alle } i \in \left\{1, \ldots, r\right\}.
  \end{align*}

  \begin{proof}
    \begin{itemize}
      \item[„$\Rightarrow$“] Durch die Definition der Primitivwurzel modulo $p$
        und dem kleinen Satz von Fermat darf eine Potenz $a^n$ mit
        $n \in \Z_p^*$ nur für den Fall $n = p-1$ kongruent zu $1$ sein. Wäre
        sie es für ein anderes $n$, dann wäre $a$ keine Primitivwurzel.
      \item[„$\Leftarrow$“] Sei $m$ die Ordnung von $a \Mod{p}$ in $\Z_p^*$.
        Nach dem Satz von Lagrange gilt $m \mid (p-1)$. Wenn $m < p-1$ wäre,
        dann müsste es einen Primteiler $q_i \mid (p-1)$ geben, so dass
        $m \mid (p-1)/q_i$, woraus folgt $a^{(p-1)/q_i} \equiv 1 \Mod{p}$. Dies
        ist ein Widerspruch zur Voraussetzung. Demnach hat $a$ die Ordnung
        $m = (p-1)$ und ist Primitivwurzel.
    \end{itemize}
  \end{proof}
\end{satz}

Mit Satz~\ref{satz:primitivwurzeltest} können wir effizienter eine
Primitivwurzel finden. Wenn wir eine solche gefunden haben, können wir sogar
alle anderen Primitivwurzeln mit dem folgenden Satz bestimmen.

\begin{satz}\label{satz:primitivwurzeln_durch_potenzen}
  Sei $a$ eine Primitivwurzel von $\Z_p^*$. Es ist $a^k$ genau dann eine
  Primitivwurzel von $\Z_p^*$, wenn $k$ und $p-1$ (die Ordnung von $\Z_p^*$)
  teilerfremd sind.

  \begin{proof}
    \begin{itemize}
      \item[„$\Rightarrow$“] Wir setzen $b := a^k$ und nehmen an, dass $k$ und
        $p-1$ teilerfremd sind. Dann gibt es nach dem Lemma von Bézout ganze
        Zahlen $s, t$ mit $s k + t (p-1) = 1$. Daraus folgt
        \begin{align*}
          b^s \equiv a^{k s} \equiv a^{1 - t (p-1)} \equiv a \mod p,
        \end{align*}
        da
        \begin{align*}
          a^{- t (p-1)} \equiv {\left(a^{(p-1)}\right)}^{-t} \equiv 1^{-t} \equiv 1 \mod p
        \end{align*}
        Mittels $b$ kann demnach die Primitivwurzel $a$ erzeugt werden, sodass
        $b$ selbst alle Elemente von $\Z_p^*$ erzeugen kann. Damit ist $b$ eine
        Primitivwurzel.
      \item[„$\Leftarrow$“] Sei wieder $b := a^k$. Wir nehmen an, dass $b$ eine
        Primitivwurzel von $\Z_p^*$ ist. Dann gibt es ein Element
        $s \in \Z_p^*$, so dass $b^s \equiv a \Mod{p}$. Also ist
        $a^{ks} \equiv a \Mod{p}$, woraus $a^{ks - 1} \equiv 1 \Mod{p}$ folgt.
        Demnach muss $ks-1$ ein Vielfaches der Gruppenordnung $p-1$ sein, sodass
        es eine ganze Zahl $t$ mit
        \begin{align*}
          ks - 1 = t(p-1)
        \end{align*}
        geben muss. Dies bedeutet aber, dass $k$ und $p-1$ teilerfremd sein
        müssen.
    \end{itemize}
  \end{proof}
\end{satz}


\section{Berechnung von diskreten Logarithmen}
\label{sec:berechnung_von_diskreten_logarithmen}

\subsection{Naive Berechnung}
\label{sub:naive_berechnung}

Die einfachste Möglichkeit für die Berechnung des diskreten Logarithmus ist das
Durchprobieren. Wir erinnern uns an das \todo{verlinken} diskrete
Logarithmusproblem: gegeben sei eine Primzahl $p$, ein
Erzeuger $g$ der Gruppe $\Z_p^*$ und ein Element $y$ aus dieser Gruppe. Wir
suchen den Exponenten $x \in \Z_p^*$ für den gilt:
\begin{align*}
  g^x \equiv y \mod p
\end{align*}
Da $\Z_p^*$ nur endlich viele Element enthält, können wir für jedes $x$
überprüfen, ob es die Kongruenz erfüllt.

\begin{algorithm}
  \caption{naiver Berechnungsalgorithmus}
  \begin{algorithmic}
    \REQUIRE{$p \in \P, \left\langle g \right\rangle \in \Z_p^*, y \in \Z_p^*$}
    \FORALL{$x \in \left\{1, \ldots, p-1\right\}$}
      \IF{$g^x \equiv y \mod p$}
        \RETURN{$x$}
      \ELSE{}
        \STATE{$x \leftarrow x + 1$}
      \ENDIF{}
    \ENDFOR{}
  \end{algorithmic}
\end{algorithm}

\begin{listing}[H]
  \caption{Implementation des naiven Berechnungsalgorithmus’}
  \begin{minted}{python}
    def dlog_naive(root, modulus, value):
        for x in range(1, modulus):
            if pow(root, x, modulus) == value:
                return x
  \end{minted}
\end{listing}

\end{document}
